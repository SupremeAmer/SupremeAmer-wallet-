```
solidity
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SupremeAmer is ERC20, Ownable {
    uint256 public constant TOTAL_SUPPLY = 100 * 10**11 * 10**18; 
    uint256 public transferFee = 6 * 10**16; 
    uint256 public stakingRewardRate = 10 * 10**16; 
    uint256 public stakingPeriod = 30 days;
    uint256 public ownerRewardPercentage = 20 * 10**16; 

    mapping(address => uint256) public stakingBalances;

    event TransferWithFee(address indexed from, address indexed to, uint256 amount, uint256 fee);
    event Staked(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount);
    event RewardsClaimed(address indexed user, uint256 amount);

    constructor() ERC20("SupremeAmer", "SA") {
        _mint(msg.sender, TOTAL_SUPPLY);
    }

    function transfer(address _to, uint256 _amount) public override {
        uint256 fee = (_amount * transferFee) / 10**18;
        uint256 amountAfterFee = _amount - fee;

        _transfer(msg.sender, _to, amountAfterFee);
        if (fee > 0) {
            _transfer(msg.sender, owner(), fee);
        }

        emit TransferWithFee(msg.sender, _to, _amount, fee);
    }

    function stake(uint256 _amount) public {
        require(_amount > 0, "Invalid stake amount");
        require(balanceOf(msg.sender) >= _amount, "Insufficient balance");

        _transfer(msg.sender, address(this), _amount);
        stakingBalances[msg.sender] += _amount;

        emit Staked(msg.sender, _amount);
    }

    function calculateRewards(address _user) public view returns (uint256) {
        uint256 stakedAmount = stakingBalances[_user];
        uint256 reward = (stakedAmount * stakingRewardRate * stakingPeriod) / 365 days;
        return reward;
    }

    function claimRewards() public {
        uint256 rewards = calculateRewards(msg.sender);
        uint256 ownerRewards = (rewards * ownerRewardPercentage) / 10**18;
        uint256 userRewards = rewards - ownerRewards;

        _transfer(address(this), owner(), ownerRewards);
        _transfer(address(this), msg.sender, userRewards);

        emit RewardsClaimed(msg.sender, userRewards);
    }

    function setTransferFee(uint256 _fee) public onlyOwner {
        transferFee = _fee;
    }

    function setStakingRewardRate(uint256 _rate) public onlyOwner {
        stakingRewardRate = _rate;
    }

    function setOwnerRewardPercentage(uint256 _percentage) public onlyOwner {
        ownerRewardPercentage = _percentage;
    }
  j
solidity
    function unstake(uint256 _amount) public {
        require(_amount > 0, "Invalid unstake amount");
        require(stakingBalances[msg.sender] >= _amount, "Insufficient staked balance");

        stakingBalances[msg.sender] -= _amount;
        _transfer(address(this), msg.sender, _amount);

        emit Unstaked(msg.sender, _amount);
      )
